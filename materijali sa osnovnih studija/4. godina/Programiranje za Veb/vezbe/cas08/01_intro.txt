prvi primer pokazije neke osnovne funkcionalnosti, za pocetak se radi u mongo shell-u

ima ovde upustvo instalcija za windows: https://www.youtube.com/watch?v=FwMwO8pXfq0
i tu kaze i kako se mnogo baza uopste pokrece na windowsu (mongod u jednom cmd, pa mongo u drugom)
(ako je prilikom instalacije stiklirano da mongodb bude windows servis, automatski ce se prilikom pokretanja sistema
pokrenuti i 'mongod'  i onda ne moramo u 2 terminala ovako, nego samo pozivamo 'mongo')

iz shella moze da se izadje komandom:
    quit()


prikazivanje svih baza na sistemu:
    show dbs


ako zelimo da korsitimo neku konkretnu bazu: (ako vec postoji bice selektovana, 
a ako ne postoji bice kreirana)
    use ime_baze


u bilo kom trenutku u toku rada mozemo da vidimo sa kojom bazom tacno radimo:
    db 


izlistavanje kolkecija u bazi u kojoj radimo:
    show tables


kolekciju mozemo da pravimo sa 'create collection' komandom ali cesce u praksi cemo hteti
da se kolekcija sama napravi kada dodamo neki dokument u nju. To moze ovako:
    db.ime_kolekcije.insert({...})
primer:
    db.users.insert({username: 'pera', password: 'pera123'})
NOTE: kada pisemo ovu komandu u mongosh, mozemo i iz vise redova, ukucamo db.users.insert({ pa enter
i onda red po red unosimo podatke
Ova komanda vraca broj ubacenih objekata


----- pretraga -----

izlistavanje dokumenata u kolekciji:
    db.ime_kolekcije.find({...objkat restrikcije...})
Ako hocemo da izlistamo sve, objekat restrikcije moze da bude prazan, npr:     db.users.find({ })


Svaki entry u bazi ima svoj automatski generisan jedinstveni ID


Lepsi ispis moze ovako da se dobije:
    db.ime_kolekcije.find({...objkat restrikcije...}).pretty()


finija pretraga se radi tako sto u find u objektu restrikcije navedemo tacno sta hocemo da trazimo:
    npr.     db.users.find({status: 'active'})
(ako svojstvo koje trazimo ne postoji u nekom dokuemntu, to se racuna kao da ne zadovoljava uslov pretrage)


Ako nam je neko svojstvo niz vrednosti, npr progSkills: ['JS', 'Python'], pretraga se radi na identican nacin,
npr hocemo da izlistamo sve korisnike koji znaju JS:
    db.users.find(progSkills: 'JS')
tj navodi se samo ovako kao obicna vrednost, ne kao neki niz
NOTE: ako bas hocemo da nadjemo neki podniz, mora da bude u istom poretku kao u originalnom nizu:
npr u nasem primeru:    db.users.find(progSkills: ['JS', 'Python'])   vraca dobar rezultat, ali
db.users.find(progSkills: ['Python', 'JS'])    ne vraca dobro


Mozemo da zadamo i vise svosjtava po kojima se trazi (po defaultu u pozadini ce se desiti konjukcija uslova):
    db.users.find(status: 'active', progSkills: 'JS')


Po defaultu kada radimo find, bice nam ispisana sva svojstva dokumenta koji je pronadjen. Mozemo to da sprecimo tako sto pored
objekta restrikcije koristimo i objkeat projekcije:
    db.ime_kolekcije.find({...objkat restrikcije...}, {...objekat projekcije...})
U objektu projekcije navodimo 1 ako zelimo da se neko svojstvo prikaze i 0 ako ne zelimo:
    npr:     db.users.find({status: 'active', progSkills: 'JS'}, {_id: 0, password: 0}).pretty()
Po defaultu sva svojstva se prikazuju tj imaju vrednost 1, tako da cemo ovo da korisimo uglavnom da iskljucimo neka svojstva


Neke uslove npr poredjenja u find mozmeo da dodamo u objkeat restrikcije:
    db.users.find({age: {$gt: 20}}, {_id: 0, password: 0}).pretty()
Za svojstvo koje zelimo da napravimo neki uslov pordjenja, navodimo objekat {} u kom sa $ime navodimo operaciju
imamo  eq(==), gt(>), gte(>=), lt(<), lte(<=) ... i vrednot


pretraga gde neki od uslova ima neku od dozvoljenih vrednosti:
    db.users.find({progSkills: {$in: ['PHP', 'Python']}, {_id: 0, password: 0}).pretty()
$in koristimo na slican nacin kao u prosloj komandi
 

Za disjunkciju uslova pri pretrazi, odmah se na pocetku objekta restrikcije navodi $or a onda za njegovu vrednost uzimamo
niz [] objekata koji predstavljaju uslove:
    npr.   db.users.find({$or: [{progSkills:'PHP'}, {age: {$gt: 21}}]}, {_id: 0, password: 0}).pretty()


find vraca sve dokumente koji zadovoljavaju dati uslov, a ako nam npr treba samo 1 prvi na koji se naidje koji mozemo da koristimo   
    findOne umesto find
(NOTE: primetili smo neki bag da findOne ne moze da se koristi uz .pretty() (?) )


----- azuriranje vrednosti -----
Za azuriranje imamo dostupne komande updateOne i updateMany:
    db.users.updateOne({...objekat selekcije....}. {...objekat promene (?)...})
objekat promene pocinje sa $set i prosledjujemo objekat koji govori sta menjamo na koju vrednost
npr: db.users.updateOne({username: 'pera'}, {$set: {password: '123pera'}})


inkrementacija nekog svojstva:
    npr: db.users.updateOne({username: 'mika'}, {$inc: {age: 5}})    (navodimo svojstvo i za koliko se inkrementira)


ima jos komandi, vidi dokumentaciju ako treba


----- brisanje vrednosti -----
slicno sve kao update, imamo deleteOne i deleteMany
    npr: db.users.deleteOne({username: 'pera'})


kolekciju na nivou baze na kojoj radimo mozemo da obrisemo sa:
    db.ime_kolekcije.drop()
npr. db.users.drop()


cela baza sa kojom radimo moze da se obrise:
    db.dropDatabase()